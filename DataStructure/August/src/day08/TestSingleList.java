package day08;
/*
在该类中将会实现一个简单的链表，使用的是穷举的方式，没有一个一个方法的封装出来，目的是为了快速地让同学能够清洗的认识到链表的结构
链表也是属于顺序表中的一种，链表的物理结构是链式存储结构，在计算机的存储上内存是不连续的，但是链表的逻辑结构是线性结构，数据元素之间是
一对一的关系，而且在逻辑上是连续的，所以被归在了顺序表中。
我们知道链表的基本单位是节点，节点是通过两个部分组成的，一个是var域保存的是数据，是基本数据类型；
另一个是next域保存的是下一个节点内存地址，是引用数据类型。
我们如果想实现链表，那么就需要先把链表的基本单位节点抽象出来，所以先把节点封装成一个类，节点的内部有var域和next域。
链表的种类有很多，我们可以通过三组来分配（带头，不带头），（循环，非循环），（双向，单向），排列组合之后就会发现8种类型。
但是我们主要学习的是“单向不带头非循环”和“双向不带头非循环”。其中“双向不带有非循环”其实就是LinkedList底层的实现逻辑。
 */

/**
 * 单向不带头非循环链表的粗略实现
 */
public class TestSingleList {
//封装节点，我们这里写在静态内部类中
//静态内部类有两个特点：
//1.无法在静态内部类中访问非静态外部类的对象；2.创建静态内部类的对象不需要通过创建外部类的对象来访问，而是直接使用外部类和内部类的类名来访问
static class Node{
    //var域
    public int var;
    public  Node next ;
    //调用有参构造方法创建对象的时候，jvm就不会自动调用没有不可见的缺省构造器了
    //调用Node的有参构造方法，创建有参构造方法的同时我们还可以把var值给确定了
    public Node(int var){
        this.var = var;
    }
}
//始终指向头节点的head索引
    public Node head;
/**
 * 创建链表的方法
 */
public void createList(){
    //准备几个节点，但是目前这几个节点没有任何联系，因为只有节点中的var域被初始化了，而next域都为默认值null
    Node node1 = new Node(10);
    Node node2 = new Node(12);
    Node node3 = new Node(23);
    Node node4 = new Node(34);
    //想办法把这几个节点联系起来，而且是要通过链表的逻辑结构来实现
    //那就是让一个节点的next域等于下一个节点的内存地址，依次往下连，直到遇见尾节点的next为空就可以了
    node1.next = node2;
    node2.next = node3;
    node3.next =  node4;
    //node4节点我们就可以不用管了因为node4就已经是尾节点了，next值为null
    head = node1;//head要指向头节点的位置
}
//现在我们就来实现如何遍历链表
    /*
    问题一：如何实现一个节点往下一个节点走？
    问题二：怎么做才能让head必须一直指向链表的头节点？
    问题三：想好用循环实现的时候，应该选择哪个循环？
    问题四：循环终止条件应该是什么？
    解答：
    1.head = head.next;(然后循环这个语句达到遍历链表的目的)
    2.找一个辅助变量 Node cur = head;
    3.使用while循环，因为这里的遍历用不到索引i++
    4.while(cur!=null),这样才能过遍历完，而不会漏掉。如果使用cur.next!=null就会漏掉尾节点
     */
    public void display(){
        Node cur = head;//类比迭代器
        while(cur!=null){
            //结束的条件就是当迭代器把尾节点也指完之后，就指向null了
            System.out.println(cur.var+" ");
           cur = cur.next;
        }
    }
}
//现在我们就可以写一个测试类，完成当前这个粗略的链表的具体操作