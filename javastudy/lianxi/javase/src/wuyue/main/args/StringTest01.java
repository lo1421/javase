package wuyue.main.args;
/*
java中在JDK中内置的一个类java.lang.String
1.String表示字符串类型，属于引用数据类型，不属于基本数据类型
2.在Java中但凡是使用双引号括起来的全部都是String类型对象，eg：“abc”，“123”等等。这两个是字符串类型的对象
3.在java中规定双引号括起来的字符串一旦生成就不可变，即“abc”从出生到死亡都不可变，不能变成“abcd”,也不能变成“ab”
4.在JDK中双引号括起来的字符串，都是直接储存在方法区当中的“字符串常量池”当中的
为什么SUN公司要把字符串对象储存在方法区中的“字符串常量池当中”？，因为字符串在实际的开发中使用的十分的频繁，所有为了提高编程的
效率，就选择将字符串对象储存在方法区的“字符串常量池”中，那么效率是如何具体提高的呢，接下来我将使用代码以及内存图来为你讲解


 */
public class StringTest01 {
    //创建字符串对象
    //静态初始化字符串对象
    String s1 =  "abcdef";
    String s = "xy";
    String s2 = "abcdef" + "xy";

    //动态初始化字符串对象
    String s3 = new String("xy");//但是这里的new运算符是会在堆内存中创建一个对象出来，我们可以检验看看
    //思考这里的“xy”是重新在方法区的字符串常量池中创建出来的还是直接使用上述已经创建好了的字符串对象“xy”，答案是，跟之前讲的一样，不用再重新创建
    //因为字符串对象是保存在方法区当中的，一个字面值只用初始化一次即可


    //这里的加号是字符串连接符，连接的结果是一个字符串
    //那么上述两行代码在JVM内存图中是如何呈现的呢？
    public static void main(String[] args){
        StringTest01 st  = new StringTest01();

        System.out.println(st.s2);
        /*
        由于字符串对象本身就是字符串，那么使用print 方法直接输出对象的引用，就已经是输出对象的字符串了，就不会再调用引用类型当中继承或者重写的方法了吧
        这里肯定是调用String类重写父类中的ToString方法，因为SUN公司在封装String类的时候是重写了从Object 类当中继承的方法了的
        重写之后的具体实现，就是输出字符对象或者字符串的引用都会调用toString方法返回这个字符串的字面值，那我应该怎么做才可以输出对象的内存地址呢？
         */
        System.out.println(st.s);
        System.out.println(st.s3);
    }
}
/*
使用有参构造方法创建字符串对象时，新创建的字符串对象在堆内存中保存的是参数的字符串的字面值，而不是字符串在字符串常量池中的内存地址。

当使用有参构造方法`new String(String)`创建字符串对象时，参数中的字符串会被复制到新的字符串对象中，而不是简单地引用字符串常量池中的内存地址。
这意味着新创建的字符串对象在堆内存中拥有自己的存储空间，并且存储的是参数字符串的值，而不是引用。

例如，考虑以下代码片段：

```java
String str1 = "Hello"; // 存储在字符串常量池中
String str2 = new String(str1); // 在堆内存中创建新的字符串对象，值为"Hello"
```

在第一行代码中，字符串字面值"Hello"被存储在字符串常量池中。

在第二行代码中，使用有参构造方法`new String(str1)`创建了一个新的字符串对象。
该构造方法会复制参数字符串`str1`的值，即"Hello"，并在堆内存中分配一块新的内存空间用于存储这个值。

因此，在堆内存中创建的字符串对象保存的是参数字符串的字面值，而不是字符串在字符串常量池中的内存地址。
 */

/*
当通过静态方法（如`String.valueOf()`）或构造方法（如`new String()`）来创建字符串对象时，
即使使用了字符串字面值，也会在堆内存中创建新的字符串对象。
这是因为这些方法的调用会显式地使用`new`关键字创建一个新的字符串对象，而不是使用常量池中的引用。

例如，考虑以下代码片段：

```java
String str1 = new String("Hello"); // 在堆内存中创建新的字符串对象
String str2 = "Hello"; // 优先使用常量池中的字符串引用
```

在第一行代码中，使用了构造方法`new String()`来创建字符串对象，即使传入了字符串字面值"Hello"，也会在堆内存中创建一个新的字符串对象。
这是因为使用了`new`关键字显式地要求创建一个新对象。

而在第二行代码中，直接使用字符串字面值赋值给变量，编译器会检查常量池中是否已经存在相同内容的字符串。
如果存在，则直接使用常量池中的引用，而不会在堆内存中创建新的字符串对象。这样可以节省内存空间并提高性能。

所以，通过静态方法或构造方法创建字符串对象时，即使使用了字符串字面值，也会在堆内存中创建新的字符串对象，而通过字符串字面值进行静态初始化时，
会优先使用常量池中的字符串引用。
 */
