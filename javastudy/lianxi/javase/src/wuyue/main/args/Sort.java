package wuyue.main.args;
/*
在进行冒泡排序之前我们应该了解冒泡排序的基本原理是什么？
接下来列举一个具体的例子，然后你通过具体的例子来总结规律，然后基于具体的例子你就可以写出一个抽象的冒泡排序的具体的代码
这个代码块就可以实现将数组中的元素中的数据从小到大进行排序，其实你也可以自定义重大到小的排序，
冒泡排序是java中的java.util.Arrays类当中的sort方法，这可方法可以实现对集合和数组的排序
算法排序有基本的两种：冒泡排序算法和选择排序算法
1.冒泡排序算法：
通过相邻两元素的比较，将左边大的元素和右边小的元素进行交换位置，然后元素索引增加一，若数组长度为n，那么只需要循环n-1次即可
这样就模拟出大的泡泡被冒出去的现实的例子变成在程序中，一堆比较的数据没参加一次循环就会固定一个最大的数据的位置，直到剩下两个元素参与比较
比较完之后，所有的元素的位置都被固定好了
2.选择排序算法：
选择排序算法的效率比冒泡排序的效率高，高在选择排序的算法每次两个元素的位置的交换都是有意义的，选择排序的基本的原理是什么？
外层循环的上下限都是固定的，，外层循环每进行一次就是实现把参与比较的这一堆数组中最小的选择出来之后，会给这被选择出来的元素的位置安排好
内层循环的下限是随着外层循环的次数的增加而改变的，但是内层循环的上限是不变的，原理是取出参与比较的最左端的元素与它后续的每个元素都比较，
找出最小的元素之后，把这个最小的元素跟这堆数据中的最左端的元素进行位置交换，这样就实现固定了数组中的一个元素，若数组中有n个元素来排序，那么
就只需要比较出n-1个数据即可，就可以实现这个数组的排序
 */
public class Sort{
    public static void main(String[] args) {
        //创建一个整数型数组对象，实现对该数组的排序
        int[] arr = {6,4,8,1,9,3};
        int count = 0;
        int count1 = 0;
        int count2 = 0;
        int count3 = 0;
        for (int i = 0; i < arr.length-1; i++) {
            //这里是外层循环，目的是每循环一次都会冒出一个大泡，这个大泡不需要参与接下来的比较，因为它在上一次的内层循环中已经排好位置了
            //i的取值范围[0,arr.length-2] 这个集合中一共有arr.length-1个取值
            count++;//计算 这个数组比较了几次？
            for (int j = 0; j < arr.length-1-i; j++) {
                //使用冒泡排序的话，那么内层循环的上限是随着外层循环的取值而变化的
                //但是内层循环的下限由于定义成索引来循环迭代，那么使用冒泡排序的话内层循环的下限是不变的
                //在这里我们将实现对每每对两个元素进行比较，如何才能达到交换位置的标准呢
                //当比较的两个元素左边的索引对应的元素大于右边索引对应的元素的数值，那么就让这两个元素进行位置的交换
                if(arr[j]>arr[j+1]){
                    //这里涉及到了两个元素交换位置的常用的模型，那就是多定义一个暂时储存的变量来视为盒子来作为中转站
                    int temp ;
                    temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = temp;
                    count1++;//这里是计数这个数组比较过程中交换了几次？
                }
            }
        }
        System.out.println("该数组比较的次数："+count);
        System.out.println("该数组交换的次数："+count1);
        //调用遍历的方法实现对比较完之后的数组的便利的功能
        print(arr);
        //再创建一个数组对象，这当中保存的数据跟上述定义的数组保存的数据是一样的，只不过这次我们的排序算法使用的是选择排序
        System.out.println();
        System.out.println("------------------------------------------------------");
        int[] arr1 = {6,4,8,1,9,3};
        //选择排序代码的实现
        for (int i = 0; i < arr1.length-1; i++) {
            count2++;//计算 这个数组比较了几次？
            //外层的循环i的取值范围为：[0,arr1.length-2],循环的次数即i的取值总数为arr1.length-1
            int min = i;//假设arr1就是最小的数据，那么就应该保存到储存最小数据的这个变量中，也就是我们定义的的这个盒子
            for (int j = i+1; j < arr1.length; j++) {
               //内层循环的上限是发生改变的，我们直接把外层循环的i当做每次当前循环参与比较的数据中的最左端数据的最左段的数据
               //选择排序算法的核心是什么？主要是实现把当前参与循环的这一对数据中的最小元素找出来之后。并为这个元素排好顺序
               //我们假设每次参与比较的数据中最左端的数据假设为最小的数据，若后续比较的过程中发现了比这个假设的数据还要小，我们就把这个储存更小的
               //的值保存到这个假设保存最小数据的盒子当中

               if(arr1[min]>arr1[j]){
                   min = j;
               }
            }
            //交换位置的条件就是假设错误的时候
            if(i!=min){
                int temp1 ;
                temp1 = arr1[i];
                arr1[i]= arr1[min];
                arr1[min] = temp1;
                count3++;//这里是计数这个数组比较过程中交换了几次？
            }

        }

        System.out.println("该数组比较的次数："+count2);
        System.out.println("该数组交换的次数："+count3);
        //调用遍历数组的方法
        print(arr1);
    }
    //遍历数组方法的定义
    public static void print(int[] arr){
        for(int i = 0;i<arr.length;i++){
            System.out.print(arr[i]+" ");
        }
    }
//如果我现在将同样的一组数据拿来使用选择排序算法来实现，那么又会是怎样的结果呢？
}
/*
C:\Users\14214\jdk-17.0.6\bin\java.exe "-javaagent:D:\IDEA\IntelliJ IDEA Community Edition 2023.1\lib\idea_rt.jar=60393:D:\IDEA\IntelliJ IDEA Community Edition 2023.1\bin" -Dfile.encoding=UTF-8 -classpath D:\Users\14214\javase\javastudy\out\production\javase wuyue.main.args.Sort
该数组比较的次数：5
该数组交换的次数：8
1 3 4 6 8 9
------------------------------------------------------
该数组比较的次数：5
该数组交换的次数：4
1 3 4 6 8 9
Process finished with exit code 0

 */
