/*
在外部程序访问Person类的实例变量age
*/
public class PersonTest{
	public static void main(String[] args){
		/*要想访问Person类的实例变量必须先创建一个对象
		创建对象以及属性初始化是通过调用构造方法完成的
		而构造方法的调用语法： new 构造方法名/类名(实际参数列表);
		又因为实际参数列表有参数和没有参数可以姜构造方法分为两大类
		1.无参构造方法（缺省构造器）
		2.有参构造方法（通过参数的个数，类型区分）
		又因为构造方法的方法名必须跟类名相同，所以满足方法的重载的三大条件：在同一个类中、方法名相同且功能相似、形式参数列表不同。
		构造方法的定义语法
		[public] 方法名（形式参数列表）{
			构造方法体
		}
		*/
		Person p = new Person();
		//访问Person类型的实例变量age
		/*
		补充：实例变量的访问通常有两种操作：
		1、读数据（get获取）
		2、改数据（set设置）
		*/
		//读aeg（get获取）
		System.out.println(p.age);//0
		//改age（set设置）
		p.age = 20;
		//读age（get获取）
		System.out.println(p.age);//20
		//改age（set设置）
		p.age = -100;
		//读aeg（get获取）
		System.out.println(p.age);//-100
	}
}
/*
仔细分析上述代码存在的bug
1、通过33行随意改的age在实际问题中，一个对象（人类）的年龄（age实例变量或者属性）是不可能为负数的
2、那么，通过PersonTest这个外部程序目前是可以随意访问age，既可以读age又可以改age，按照实际的业务要求一个人的年龄为负数是不可能的，
   但是程序目前还是让他通过了，这其实就是程序潜在的一个bug
3、因为在PersonTest程序中随意访问了Person内部数据（实例变量）导致了不安全
解决：
尝试对Person类的内部数据进行封装一下
不再对外暴露复杂的数据，对外只提供简单的操作入口
优点：
1.数据安全了
2.调用者也方便了
备注：具体步骤见Person01和PersonTest01两个程序
*/