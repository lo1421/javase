/*
通过对java面向对象的三大特征的前两个封装和继承我们可以知道
封装：
第一步：私有化的方法和属性（使用private修饰的属性和方法）
私有化的方法和属性就只能在本类中访问和调用
第二步：对外部提供简单的访问入口（必须是实例方法）
给每个私有化的属性和方法都设置一个或者多个的访问入口（实例方法）去访问和调用这些私有化的属性和方法
这样是运行的，因为私有化的属性是可以访问和调用的，当我在外部（别的类）想要访问和调用这些别的类已经私有化的方法和属性的时候，
我是不能访问的，变量会报错：变量xx是xx类中private访问控制；方法会报错：找不到符号。
此时我就可以调用那个类对外部提供的访问入口（实例方法）来实现
间接访问
继承：
当子类继承了父类之后，子类继承了父类所有除构造方法以外的所有都复制粘贴了过来，只是不可见的，但是确实存在。但是子类无法访问父类私有化的属性和方法
那么子类也确实继承了父类私有化的属性和方法，但是在子类中无法直接访问父类中继承过来的私有化的方法和属性
那么这个时候我想在子类（这里相当于外部）访问父类中的私有化的属性和方法，就应该在父类中提供入口
*/
/*
首先定义一个父类
父类中提供一个私有属性a和私有方法show()
再提供两个公有的方法分别获取私有变量a和私有方法show()
*/
class Fu{
	private int a;
	public Fu(){
		
	}
	public Fu(int a){
		this.a = a;
	}
	private void show(){
		System.out.println("父类私有方法执行了！");
	}
	public void getShow(){
		this.show();
	}
	public int getA(){
		return a;
	}
	//写一个公开方法，然后去子类中进行方法覆盖
	public void doSome(){
		System.out.println("父类dosome方法执行了");
	}
}
//子类
class Zi extends Fu{

	public Zi(){
		
	}
	//访问从父类继承过来的不可见的私有属性
   
   public Zi(int b){
		super(b);//这里涉及到了子类调用父类的有参构造方法,这里编译是通过了的，也没有报错
		//这是因为我使用了super()实现在子类中访问父类的构造方法
	}
	public  void show(){
		System.out.println("子类方法执行了！");//zi.getShow();还是输出：父类私有方法执行了！
		//这说明私有方法不存在方法覆盖
	}
	//公开方法的方法覆盖
	public void doSome(){
		System.out.println("子类dosome执行");
	}
	
	
}
//测试类
public class Test{
	public static void main(String[] args){
		/*
		Zi zi = new Zi(2020);
		System.out.println(Zi.a);//a 在 Fu 中是 private 访问控制
		Zi.show();//找不到符号
		所以虽然子类可以继承父类私有化的属性和方法，但是子类中没有访问父类私有成员的权限，隐藏我们可以通过
		getA()和show()方法去访问父类继承过来的私有成员
		*/
		//修改如下
		Zi zi = new Zi(2020);//调用子类的有参构造方法创建对象
		//通过子类引用去访问从父类中继承的私有化的属性
		System.out.println(zi.getA());//2020
		//通过子类引用去访问从父类中继承的私有化的方法
		zi.getShow();//父类私有方法执行了！
		//这里执行的依旧是父类中的show()
		//说明私有方法不存在方法覆盖但能够继承
		
		//要是我对继承过去的方法进行方法覆盖呢？
		Fu fu = new Zi(2021);
		fu.doSome();//子类duSome执行
		zi.doSome();//子类dosome执行
		//这说明公开的方法可以进行方法覆盖
		//私有方法不能进行方法覆盖
		fu.getShow();//父类私有方法执行了！
		/*
	 无论我是使用子类引用间接访问子类从父父类继承的重写了的show()方法
	 还是我使用父类引用访问子类对象再间接访问从父类继承的重写了的show()方法，
	 都是执行的父类的show()方法，而没有执行重写的子类中的show()方法
	 说明私有的方法不存在方法覆盖一说
		*/

	}
}