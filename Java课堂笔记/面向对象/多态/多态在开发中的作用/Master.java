public class Master{
	
	//喂养宠物的方法
	
	/*
	//假设这个群时候主人只喜欢养宠物狗
	public void feed(Dog d){
			d.eat();
	}
	//继续在Master类当中添加一个方法可以完成喂养猫！
	public void feed(Cat c){
		    c.eat();
	}
	
	
	//上述这两个方法其实是方法重载的知识点：
	
	
	
	发生方法重载的条件：
	1.在同一个类当中
	2.方法名一样，且功能相似
	3.形式参数列表不同（形参个数，形参类型，形参顺序）
	*/
	//现在将对这个Master类的扩展性增强，减少跟具体对象的耦合度
	//喂养宠物的方法
	public void feed (Pet p){
		//使用instanceof运算符来判断一下传进来的对象是哪个吧！
		//为什么要判断是哪个对象传进来了？
		/*
		因为有时候调用你这个feed()方法的人他传对象进来的时候，你也不知道他要传什么，如果你要使用向下转型的话
		就可能出现ClassCastException错误，所以使用向下转型前可以判断一下对象类型。
		而且你Master面向的是抽象对象，不是具体的对象，所以设置instanceof关卡是很有必要的
		但是你这里是父类型引用调用子类型对象的覆盖的方法，就没有使用向下转型
		
		*/
		p.eat();
	}
	
}