/*
接下来我们将学习多态（面向对象的三大特征之一）
先有封装，有了封装就有一个整体，然后就可以有继承，又了父与子的继承关系，就有了多态
多态的学习分为两部分：多态的基础语法和多态在开发中的作用
多态的基础语法
一。学习多态之前，我们必须掌握多态的基础语法之前需要普及两个概念
1.向上转型（自动类型转换）
子类对象自动转换成父类引用（子->父）

2.向下转型（强制类型转换）
注意：java中引用数据类型其实不存在自动类型转换和强制类型转换的说法，自动类型转换和强制类型转换的说法是基本数据类型中中的说法
引用数据类型只存在向上转型和向下转型，只是为了好理解，类比着学习，就说向上转型是自动类型转换，向下转型是强制类型转换

重点（大前提）：无论是向上转型还是向下转型这两个转型的类必须有继承关系，而且只有有了继承关系，你才分的清上和下（父和子）
没有继承关系就没有向上和向下转型，你非要写两个没有继承关系的类进行类型转换，就会编译报错：不兼容的类型：xxx类无法转换为xxx类
父类引用强制转换成子类对象（父->子）
二。多态指的是：父类引用指向子类对象
1.父类引用调用子类继承的方法或者继承后重写/覆盖的实例方法（这样的方法父类子类都有的实例方法）时，就采用向上转型（自动类型转换）
2.父类引用调用子类特有的实例方法（父类中没有，是子类的扩展的方法）时，就必须采用向下转型（强制类型转换），父类引用在强制类型转换符的作用下，
强制转换成子类对象，这样就可以调用子类特有的方法
三。多态是什么？
多种形态，多种状态
编译阶段：静态绑定
运行阶段：动态绑定	
*/
/*
接下来我将编写
一个测试类
一个Animal作为父类
一个Cat子类
一个Bird子类
*/
//测试类Test01
public class Test01{
	public static void main(String[] args){
		//创建对象，通过对应的自己的引用去掉自己的方法
		Animal a1 = new Animal();
		a1.move();//动物在移动！
		Cat c1 = new Cat();
		c1.move();//Cat在走猫步！
		Bird b1 = new Bird();
		b1.move();//Bird在飞行！
		//以上都是引用指向同类型的对象，然后去调用对象的方法
		//那么代码是否能这样写？父类的引用指向子类的对象
		Animal a2 = new Cat();//编译通过
		//然后使用父类引用a2去调用子类的方法
		//首先Animal和Cat是有继承关系的两个类，Animal是父类，cat是子类
		//所以Cat is a Animal是符合伦理的
		//我们去看看编译会不会通过？  
		/*
		Animal a2 = new Cat();
		new Cat();调用无参构造器在堆内存开辟空间创建了子类型Cat对象
		Animal a2声明了一个父类型的引用，这个引用可以保存对象在堆内存中的地址
		Animal a2 = new Cat();这就是将子类型的对象在堆内存中的地址赋值给了父类型的对象，这是因为父类和子类之间有继承关系
		上述过程就是向上转型
		子类型对象自动转换为父类型引用
		*/
		Animal a3 = new Bird();//编译通过
		/*
		经过测试可知，java中父类引用是可以指向子类对象的，因为编译通过了的，
		这说明java中有这样一个语法：
		父类型引用允许指向子类型对象
		Animal a2 = new Cat();
		这其中a2就是父类型引用，new Cat();这是创建的一个子类型对象
		允许a2这样的父类型引用指向子类型对象new Cat()
		那么若两个没有继承关系的类还能这样写吗？？？？
		*/
		/*
		假设现在有一个没有继承Animal类的Dog类
		
		Animal a4 = new Dog();//编译报错
		Test01.java:: 错误: 不兼容的类型: Dog无法转换为Animal
                Animal a4 = new Dog();
				所以要使用父类型引用指向子类型对象必须这两个类是继承关系！！！！！
	*/	
	//调用a2的move()方法
	a2.move();//Cat在走猫步！
	//执行的结果应该是什么？？
	a3.move();//Bird在飞行！
	//这说明父类型引用指向子类型对象时，调用的move()方法是子类当中方法覆盖的方法
	}
}
//Animal类 父类
class Animal{
	//动物移动move的方法
	public void move(){
		System.out.println("动物在移动！");
	}
}

// Cat类 子类
class Cat extends Animal{
	//对从父类继承过来的move()方法进行重写/方法覆盖
	//进行方法覆盖的时候一定要去父类复制粘贴过来，靠手动写，容易写错
	public void move(){
		System.out.println("Cat在走猫步！");
	}
}
//子类Bird
class Bird extends Animal{
	//对从父类继承过来的move方法进行方法覆盖
	public void move(){
		System.out.println("Bird在飞行！");
	}
}
//没有继承Animal类的Dog类
class Dog{

	
}
/*
分析：
一、什么是多态？
多种形态，多种状态
针对分析：
Animal a2 = new Cat();
a2.move();
java程序分为编译阶段和运行阶段
1.先分析编译阶段
对于编译器来说，编译器识别出a2变量在声明时的类型是Animal类型，所以编译器在检查语法的时候会去Animal.class字节码文件中
找到move()方法，找到了之后，会绑定上move()方法，编译通过，静态绑定成功
（编译阶段属于静态绑定）
2.在分析运行阶段
运行的时候，实际上在堆内存中创建的java对象是Cat类型对象，所以调用move()方法的时候，真正参与的对象是一只猫，所以运行阶段会
执行Cat对象的move()方法，这个过程属于运行阶段的动态绑定
（运行阶段的绑定属于动态绑定）
二、多态表示多种形态，多种状态
编译的时候是一种状态
运行的时候是一种状态
编译阶段：静态的绑定父类中的方法
运行阶段：动态的绑定子类中的方法
*/
//实现了父类型引用指向子类型对象，而且还完成了父类型引用调用子类型对象从父类型继承过去的但是重写了的方法
//思考？那么既然子类又名扩展类，衍生类，那我子类中应该时常会有父类中没有的方法，是我子类特有的方法
//这个时候我还能实现父类引用去调用子类型对象特有的对象吗？？？？？？
//带着这个思考，我们一起去Test02程序一探究竟吧！

