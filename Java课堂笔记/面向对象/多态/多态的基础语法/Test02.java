/*
1.既然父类型引用以及实现了指向子类型对象，已经实现了调用子类从父类继承过去重写了的方法（这样的方法是父类和子类特有的）
2.如果现在父类型引用要去访问子类型对象所特有的方法，此时我们又应该使用什么样的手段或者语法达到目的呢？
3.为什么我会考虑到父类型引用去访问子类型对象的特有方法呢？
这是因为子类又名“扩展类”“衍生类”，那么子类往往会有除了从父类继承过来的方法，还会有自己特有的方法，既然我父类引用已经实现
保存子类型对象的堆内存（也就是向上转型），那么我可不可以就继续利用这个已经保存了子类型对象堆内存地址去访问子类型特有的方法？
*/
//测试类
public class Test02{
	public static void main(String[] args){
	//创建对象，使用向上转型
	Animal02 a1 = new Cat02();
	//a1.catchMouse();//报错：找不到符号
	//底层对象是一只猫，分析这个程序是否能编译和运行呢？
	/*
	编译阶段：
	编译器识别到a1变量声明时是Animal02类型的，那么编译器会按照语法，到Animal02.class字节码文件下找catchMouse()方法
	很显然父类Animal02.class字节码文件中 没有catchMouse()方法，那么静态绑定失败了（语法不合法）
	会报错：找不到符号
	那么我们有没有其它办法来实现父类型引用指向子类型对象特有的方法呢？
	这个时候就需要用到“向下转型”强制类型转换
	不要随意的使用强制类型转换
	当你需要访问的是子类型对象中"特有"的方法的时候必须进行向下转型
	*/
	//向下转型
	Cat02 c = (Cat02)a1;
	//使用强制类型转换法将父类型引用强制转换成子类型然后声明了一个子类型变量去接收转换后的结果
	//调用子类特有的方法
	c.catchMouse();//猫在抓老鼠
	/*
	可以不使用变量接收吗？不可以
	*/
	//(Cat02)a1.catchMouse();//报错：不是语句
	Animal02 a2 = new Bird02();
	//强制类型转换，向下转型
	Bird02 b = (Bird02)a2;
	//调用子类特有的方法catchWarm();
	b.catchWorm();//鸟在抓虫子
	/*
	现在我们已经实现了使用向下转型的语法，实现了父类型引用调用子类型对象所特有的方法
	*/
	//思考：我们之前也遇见过基本数据类型的强制类型转换，这样可能会造成精度丢失，那么我们在多态中的引用数据类型的强制转换会有风险吗？
	Animal02 a3 = new Bird02();//底层对象是一只鸟
	//强制类型转换//强制类型转换前先进行判断
if(a3 instanceof Cat02){
	Cat02 c1 = (Cat02)a3;//报错：java.lang.ClassCastException: class Bird02 cannot be cast to class Cat02 
	c1.catchMouse();
}//由a3进行强转前指向的对象不是Cat02类型的，所以instanceof运算结果为false，那么if（false）{}就不会进大括号内，
//这样你就避免了引用强转前后指向的对象不一致这样的风险
//也就不会在运行阶段发生“ClassCastException”类转换异常。
//程序员要保持一个好习惯，进行向下转型“强制类型转换”时，使用instanceof运算符和if条件语句搭配使用，规避ClassCastException运行的报错！！！
	//分析以上三行程序看看编译和运行有什么区别？
	/*
	编译阶段：编译器识别到变量a3在声明时是父类Animal02类型的引用，Animal02类和Bird02类之间有继承关系，所以可以进行“向上转型”。
	然后，继续下一行，Animal02类和Cat02类之间是有继承关系的，所以可以进行“向下转型”，
	然后识别到c1在声明的时候是Cat02类型的引用，之后，编译器按照语法，会去Cat02.class字节码文件中寻找catchMouse()方法，
	找到了，然后静态绑定，编译是通过的，
	符合编译阶段的语法
	
	运行阶段：在堆内存中创建的对象其实是一只鸟，是Bird02类型的对象，然后此时父类Animal02类型的引用a3是保存的子类Bird02类型的对象
	此时强制转换的就是父类型引用指向的子类Bird02类型的对象去强制转换成Cat02类型的对象，这个时候会运行报错：
	这个报错很经典，跟同样是运行时报错的NullPointerException（空指针异常）同等重要！！！！！
	报错：java.lang.ClassCastException: class Bird02 cannot be cast to class Cat02 
	ClassCastExcepton(类转换异常)
	*/
	/*
	为了解决向下转型时存在的风险，我们都会提前判断一下，我们要强转的父类型的引用指向的对象是否跟我即将强转成功之后的对象是否是同一个类型的？
	1.我们就引入了一个运算符：instanceof
	2.instanceof运算符就可以在运行阶段动态判断引用指向的那个对象是否跟那个对象是同一个类型
	3.为什么是强调在运行阶段动态判断呢？这是因为上述情况编译是不会报错的，因为两个类之间有一个大前提：两个类有继承关系
	所以这两个类无论是进行“向上转型”还是“向下转型”都是符合编译阶段的语法的，所以编译阶段是可以通过的
	但是运行阶段对象在堆内存中创建出来了，就把创建出来的子类型对象在堆内存中的地址赋值给父类型引用了，这个时候，你要是使用“向下转型”
	就必须保证你传给父类型引用指向的底层对象必须得是你强转成功的子类型对象，这两个子类型对象必须保持前后一致，而instanceof运算符就是在运行阶段动态判断
	出你强转前后父类型引用指向子类型对象一致！！！！！
	*/
	
}
}
//Animal父类
class Animal02{
	//move()方法
	public void move(){
		System.out.println("动物在移动");
	}
	
}
//Cat子类
class Cat02 extends Animal02{
	//方法重写/方法覆盖
	public void move(){
		System.out.println("猫在走猫步");
	}
	//Cat02子类特有的方法
	public void catchMouse(){
		System.out.println("猫在抓老鼠");
	}
}
//Bird类
class Bird02 extends Animal02{
	public void move(){
		System.out.println("鸟儿在飞翔");
	}
	//Bird类特有的方法
	public void catchWorm(){
		System.out.println("鸟在抓虫子");
	}
}/*
instanceof知识点：
1.instanceof可以1在运行阶段动态判断引用指向的对象的类型
2.instanceof的语法
   引用 instanceof 类名;
3.instanceof运算符的运算结果只能是true或者false
4.
假设: "a1 instanceof Cat02"的运算结果为true，则表明父类引用c1指向的对象类型是Cat02
假设: "a1 instanceof Cat02"的运算结果为false，则表明父类引用c1指向的对象类型不是Cat02
5.instanceof运算符常常和if条件语句搭配使用，达到要“向下转型”时的关卡

*/
/*
明天我将会给你举个例子（在程序Test03中）告诉你我为什么要使用instanceof去判断父类引用指的是不是对应子类对象
因为你有时候并不知道：外部给你的父类引用传的是哪一个子类对象，这个时候你为了防止运行时发生“ClassCastException”类转换异常
你就必须设置instanceof运算符搭配条件语句作为关卡，来对应进行强制转换
，这个例题可能会启示你去体会多态在开发中的作用

*/